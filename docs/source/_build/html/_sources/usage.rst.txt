.. _usage:

Usage
=====

Emulations of Networked Control Systems in CLEAVE are centered around two core concepts: Plants and Controllers. These terms follow the terminology used in Control Systems research: Plants are physical systems we wish to control, whereas Controllers are the computational elements which perform the necessary computations for the controlling of Plants.

In the context of CLEAVE emulations, the definition of Plants and Controllers are done through configuration files written in pure Python, which are then executed through the :code:`cleave.py` launcher script. A couple of examples of such configuration files can be found under the :code:`examples/` directory:

.. code-block:: bash

    // To run a plant configuration
    (venv) $ python cleave.py run-plant examples/plant_config.py

    // To run a controller configuration
    (venv) $ python cleave.py run-controller examples/controller_config.py

Check :code:`cleave.py --help` for more details and additional options.

In the following sections we will explain how to set up NCS emulations in CLEAVE by developing and configuring Plants and Controllers from scratch and connecting them.

Plants
------

These are the representations of the physical systems wich we want to control. Plants in CLEAVE are usually physical simulations of some system we wish to monitor and act upon. Correspondingly, a Plant is composed of three subcomponents:

- A :code:`State`, which implements the discrete-time behavior of the simulated system.

- A collection of :code:`Sensor` objects, which measure specific properties of the :code:`State`, potentially transforming them, and send them to the Controller.

- A collection of :code:`Actuator` objects, which receive inputs from the Controller, potentially transform or distort them, and finally act upon specific properties of the :code:`State`.

State
^^^^^

:code:`State` objects in CLEAVE are simply instances of classes which extend from the abstract base class `cleave.api.plant.State`. This base class defines a single required method as well as two optional ones:

.. code:: python

    class State:
        @abstractmethod
        def advance(self, dt: float) -> None:
            ...
        def initialize(self) -> None:
            ...  
        def shutdown(self) -> None:
            ...


The :code:`advance(self, dt: float) -> None` method is required. It is called by the framework on every iteration of the simulation, and thus users should implement their discrete-time plant logic here. The parameter :code:`dt` corresponds to the number of seconds elapsed since the last invocation of the method.

Methods :code:`def initialize(self) -> None` and :code:`def shutdown(self) -> None` are optional. They are called by the framework at the very beginning of the Plant execution and right before shutdown, respectively. It is in these methods users should put their initialization and shutdown logic.

:code:`State` objects also need to expose the properties which that will be provided as inputs to the Controller and the properties the Controller acts upon. This is done by defining special *semantic* variables in the constructor of the :code:`State`:

- :code:`cleave.api.plant.SensorVariable` objects represent properties that will be measured by sensors and subsequently pushed to the Controller.

- :code:`cleave.api.plant.ActuatorVariable` objects represent properties that will be modified by the actuation commands generated by the Controller. The values of these variables will be directly modified by the framework as commands come in.

- :code:`cleave.api.plant.ControllerParameter` objects represent parameters passed to the controller at the beginning of the emulation (WIP, not implemented yet).

These objects are simply used to track the values during execution, and thus are completely transparent, allowing unrestricted access to the underlying raw values at all times. This means that after initialization, these variables can simply be used as normal "raw" values without having to consider the semantic variable object around it.

Furthermore, an optional "sanity check" may be attached to each semantic variable. This simply corresponds to a callable which receives the current value of the semantic variable and returns a boolean indicating if the current value is within acceptable ranges or not. This check will be executed at each time step of the Plant simulation, and if it at any point returns :code:`False` the framework will record the corresponding variable and then halt the emulation. 

An example skeleton of a :code:`State` with a single input variable and a single output variable could then look something like the following:

.. code:: python

    class ExampleState(State):
        def __init__(self):
            super(ExampleState, self).__init__()

            self.accel = ActuatorVariable(0.0)
            self.speed = SensorVariable(0.0, sanity_check=lambda s: s < 200.0) 
            # shuts down if speed ever exceeds 200.0 m/s
            
        def advance(self, dt: float) -> None:
            # To update the state, we simply read the ActuatorVariable, as it will always
            # hold the latest value from the controller at the beginning of each timestep,
            # and we write to the SensorVariable, as its value will automatically be sampled
            # by the corresponding Sensor.

            self.speed += dt * self.accel

More complex example implementations of :code:`State` classes representing Inverted Pendulum systems are included in the module :code:`cleave.impl.inverted_pendulum`.

Sensors
^^^^^^^

Similarly to :code:`State`, a :code:`Sensor` in CLEAVE corresponds to an object instance of a subclass of :code:`cleave.api.Sensor`.